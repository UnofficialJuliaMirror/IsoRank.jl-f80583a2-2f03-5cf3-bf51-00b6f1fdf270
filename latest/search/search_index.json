{
    "docs": [
        {
            "location": "/", 
            "text": "IsoRank.jl Documentation\n\n\n#\n\n\nIsoRank.isorank\n \n \nMethod\n.\n\n\nisorank(G1::SparseMatrixCSC, G2::SparseMatrixCSC,\n        b::AbstractMatrix, alpha::Real; \nkeyword arguments\n)\n\n\n\n\nCreates the IsoRank matrix. That is, finds the pagerank values of the modified adjacency matrix of the product graph of G1 and G2. b acts as node restarts allowing you to incorporate external information.     (See Rohit Singh, Jinbo Xu, and Bonnie Berger. (2008) Global alignment of multiple protein interaction networks with application to functional orthology detection, Proc. Natl. Acad. Sci. USA, 105:12763-12768.)\n\n\nArguments\n\n\n\n\nG1,G2\n : two adjacency matrices\n\n\nb\n : matrix of node similarities, not necessarily normalized\n\n\nalpha\n: weight between edge and node conservation\n\n\n\n\nKeyword arguments\n\n\n\n\ndetails=false\n : if true, returns (R,res,L) where R is the IsoRank matrix, res is the power method details structure, L is the linear operator that the power method finds the eigenvector of; if false, returns R\n\n\nSee \npowermethod!\n for other keyword arguments\n\n\n\n\nsource\n\n\n#\n\n\nIsoRank.isorank\n \n \nMethod\n.\n\n\nisorank(G1::SparseMatrixCSC, G2::SparseMatrixCSC,\n        [damping=0.85]; \nkeyword arguments\n)\n\n\n\n\nIf you don't have node similarities, you can still create a decent IsoRank matrix by doing damping like PageRank does. This is unlike the original paper that creates a bad IsoRank matrix when b = 0 or alpha = 1.\n\n\nsource\n\n\n#\n\n\nIsoRank.powermethod!\n \n \nMethod\n.\n\n\npowermethod!(L, x; \nkeyword arguments\n) -\n radius, x, [log/history]\n\n\n\n\nPerforms power method in order to find the dominant eigenvector of the linear operator L. Eigenvector is normalized w.r.t. L_1 norm. Modifies initial eigenvector estimate x.\n\n\nArguments\n\n\n\n\nL\n : linear operator\n\n\nx\n : initial estimate of the eigenvector, not necessarily normalized\n\n\n\n\nKeyword arguments\n\n\n\n\nmaxiter\n : maximum # of iterations\n\n\ntol=eps(Float64) * size(G1,1) * size(G2,1)\n : error tolerance in L_1\n\n\nlog=true,verbose=true\n : logging and printing\n\n\n\n\nsource\n\n\n#\n\n\nIsoRank.kronlm\n \n \nMethod\n.\n\n\nkronlm([::Type{T}], A, B)\n\n\n\n\nKronecker product of A and B  stored as a linear operator (from LinearMaps) so that you don't have to create the actual matrix. This is much faster than creating the matrix like the original paper does: O(|E|) instead of O(|E|^2) for each step of the power iteration where |E| is the average number of edges in the graphs\n\n\nArguments\n\n\n\n\nA,B\n : linear operators with multiply and transpose operations\n\n\nT\n : element type of the resulting linear operator\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#isorankjl-documentation", 
            "text": "#  IsoRank.isorank     Method .  isorank(G1::SparseMatrixCSC, G2::SparseMatrixCSC,\n        b::AbstractMatrix, alpha::Real;  keyword arguments )  Creates the IsoRank matrix. That is, finds the pagerank values of the modified adjacency matrix of the product graph of G1 and G2. b acts as node restarts allowing you to incorporate external information.     (See Rohit Singh, Jinbo Xu, and Bonnie Berger. (2008) Global alignment of multiple protein interaction networks with application to functional orthology detection, Proc. Natl. Acad. Sci. USA, 105:12763-12768.)  Arguments   G1,G2  : two adjacency matrices  b  : matrix of node similarities, not necessarily normalized  alpha : weight between edge and node conservation   Keyword arguments   details=false  : if true, returns (R,res,L) where R is the IsoRank matrix, res is the power method details structure, L is the linear operator that the power method finds the eigenvector of; if false, returns R  See  powermethod!  for other keyword arguments   source  #  IsoRank.isorank     Method .  isorank(G1::SparseMatrixCSC, G2::SparseMatrixCSC,\n        [damping=0.85];  keyword arguments )  If you don't have node similarities, you can still create a decent IsoRank matrix by doing damping like PageRank does. This is unlike the original paper that creates a bad IsoRank matrix when b = 0 or alpha = 1.  source  #  IsoRank.powermethod!     Method .  powermethod!(L, x;  keyword arguments ) -  radius, x, [log/history]  Performs power method in order to find the dominant eigenvector of the linear operator L. Eigenvector is normalized w.r.t. L_1 norm. Modifies initial eigenvector estimate x.  Arguments   L  : linear operator  x  : initial estimate of the eigenvector, not necessarily normalized   Keyword arguments   maxiter  : maximum # of iterations  tol=eps(Float64) * size(G1,1) * size(G2,1)  : error tolerance in L_1  log=true,verbose=true  : logging and printing   source  #  IsoRank.kronlm     Method .  kronlm([::Type{T}], A, B)  Kronecker product of A and B  stored as a linear operator (from LinearMaps) so that you don't have to create the actual matrix. This is much faster than creating the matrix like the original paper does: O(|E|) instead of O(|E|^2) for each step of the power iteration where |E| is the average number of edges in the graphs  Arguments   A,B  : linear operators with multiply and transpose operations  T  : element type of the resulting linear operator   source", 
            "title": "IsoRank.jl Documentation"
        }
    ]
}