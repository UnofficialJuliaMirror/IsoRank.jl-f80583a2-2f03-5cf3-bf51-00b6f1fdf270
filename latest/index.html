<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Isorank</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Isorank</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Introduction</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Example-usage-1">Example usage</a></li><li><a class="toctext" href="#Using-node-similarities-1">Using node similarities</a></li><li><a class="toctext" href="#Other-parameters-1">Other parameters</a></li></ul></li><li><a class="toctext" href="funs.html">Functions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Introduction</a></li></ul><a class="edit-page" href="https://github.com/vvjn/IsoRank.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><p><a href="https://github.com/vvjn/IsoRank.jl">IsoRank.jl</a> is a Julia implementation of IsoRank as described in &quot;Global alignment of multiple protein interaction networks with application to functional orthology detection&quot;, Rohit Singh, Jinbo Xu, and Bonnie Berger (2008). IsoRank.jl also contains a PageRank implementation. The greedy network alignment method is also implemented here.</p><p>IsoRank calculates the topological similarity of all pairs of nodes across two networks. IsoRank can also be used to tune prior similarities to take topological node similarity into account.</p><p>The IsoRank matrix is calculated by creating the product graph of two networks, and then performing PageRank on the product graph. PageRank is done by using the power method to calculate the dominant eigenvector of the modified adjacency matrix of the product graph. Since IsoRank.jl doesn&#39;t explicitly build the product graph in order to perform power iteration, it has much better time and space complexity compared to other implementations of IsoRank. This implementation of IsoRank runs in <code>O(K|E|)</code>, where <code>|E|</code> is the number of edges in the two networks, and <code>K</code> is the total number of iterations required to converge under the power method.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>IsoRank can be installed as follows. We also use the NetalignUtils to read networks and so we install it as follows.</p><pre><code class="language-julia">Pkg.clone(&quot;https://github.com/vvjn/IsoRank.jl&quot;)
Pkg.clone(&quot;https://github.com/vvjn/NetalignMeasures.jl&quot;)
Pkg.clone(&quot;https://github.com/vvjn/NetalignUtils.jl&quot;)</code></pre><h2><a class="nav-anchor" id="Example-usage-1" href="#Example-usage-1">Example usage</a></h2><p>We load an example network from the <code>examples/</code> directory and create an IsoRank matrix between the network and itself. We use a damping factor of 0.85 in order to calculate a good IsoRank matrix using just network topology.</p><pre><code class="language-julia">using NetalignUtils
using IsoRank

G1 = readgw(&quot;0Krogan_2007_high.gw&quot;).G
G2 = G1

R = isorank(G1, G2, 0.85)

R ./= maximum(R)
truemap = 1:size(G2,1)
randmap = randperm(size(G2,1))
println(sum(R[sub2ind(size(R),truemap,truemap)]))
println(sum(R[sub2ind(size(R),truemap,randmap)]))</code></pre><p>Given the IsoRank matrix, we perform greedy alignment as follows.</p><pre><code class="language-julia">f = greedyalign(R)</code></pre><p>Given the alignment <code>f</code>, we construct the aligned node pairs and save the node pairs to file as follows.</p><pre><code class="language-julia">nodepairs = hcat(t1.nodes, t2.nodes[f])

writedlm(&quot;yeast_yeast.aln&quot;, nodepairs)</code></pre><h2><a class="nav-anchor" id="Using-node-similarities-1" href="#Using-node-similarities-1">Using node similarities</a></h2><p>Assuming we have a matrix of prior node similarities, we can calculate the IsoRank matrix while incorporating external information. We treat the the node similarities as the personalization vector in PageRank. Here, <code>b</code> is a matrix of node similarities (but, obviously, you should use meaningful node similarities instead of random values). Here, we equally weigh topological node similarity and prior node similarity by setting the <code>alpha</code> variable to <code>0.5</code>. <code>alpha</code> must lie between <code>0.0</code> and <code>1.0</code>. To give more weight to topological node similarity, increase the <code>alpha</code> variable up to <code>1.0</code>.</p><pre><code class="language-julia">b = rand(size(G1,1), size(G2,1))

R = isorank(G1, G2, 0.5, b)</code></pre><h2><a class="nav-anchor" id="Other-parameters-1" href="#Other-parameters-1">Other parameters</a></h2><p>Maximum number of iterations and error tolerance can be set as follows.</p><pre><code class="language-julia">R = isorank(G1, G2, 0.5, b, maxiter=20, tol=1e-10)</code></pre><p>We can extract the modified adjacency matrix, <code>L</code>, of the product graph as follows. <code>vec(R)</code> is the dominant eigenvector and <code>res[1]</code> is the corresponding eigenvalue of <code>L</code>.</p><pre><code class="language-julia">R,res,L = isorank(G1, G2, 0.85, details=true)

println(norm(L * vec(R) - res[1] * vec(R),1))</code></pre><footer><hr/><a class="next" href="funs.html"><span class="direction">Next</span><span class="title">Functions</span></a></footer></article></body></html>
